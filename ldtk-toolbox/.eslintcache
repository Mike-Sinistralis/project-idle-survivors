[{"C:\\Users\\mzimm\\Documents\\Projects\\project-idle-survivors\\ldtk-toolbox\\@types\\ldtkTypes\\index.d.ts":"1","C:\\Users\\mzimm\\Documents\\Projects\\project-idle-survivors\\ldtk-toolbox\\src\\index.ts":"2"},{"size":90808,"mtime":1711511954084,"results":"3","hashOfConfig":"4"},{"size":1424,"mtime":1711557589546,"results":"5","hashOfConfig":"4"},{"filePath":"6","messages":"7","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"aiwofi",{"filePath":"8","messages":"9","errorCount":5,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":4,"fixableWarningCount":0,"source":"10"},"C:\\Users\\mzimm\\Documents\\Projects\\project-idle-survivors\\ldtk-toolbox\\@types\\ldtkTypes\\index.d.ts",["11"],"C:\\Users\\mzimm\\Documents\\Projects\\project-idle-survivors\\ldtk-toolbox\\src\\index.ts",["12","13","14","15","16","17","18"],"import { World as WorldLoader } from 'ldtk';\r\n\r\n/* \r\n  world.levels.layerInstances\r\n  - __gridSize contains the size of the grid. (Seems to always be a square so this will work for both dimentions)\r\n  - __cWid is the size of the level horizontally\r\n  - __cHei is the size of the level vertically\r\n  - If autolayer, .autoLayerTiles\r\n  - If tiles, .gridTiles\r\n  - If entities, .entityInstances\r\n    - px is an array of [x, y] coordinates\r\n    - src is the tile that occupies this coordinate [x, y]\r\n    - You can get the grid size from \r\n  \r\n  So a builder would\r\n    - For a level\r\n      - determine grid size, total width, total height\r\n      - Iterate over layerInstances from length to 0\r\n      - Fill in a 2D Array with the tiles (px/__GridSize to get the index)\r\n        - Overwrite the element as you move up the layers\r\n        - If the element being inserted is a collision layer (this seems to be arbitrary so we need a naming convention), tag it as collidable\r\n        - I don't think we will use this for entities, but we can place entities or other things randomly once the \"map\" is built\r\n*/\r\nWorldLoader.loadRaw('./src/tilemaps/dungeoun/dungeon.ldtk').then(async (world) => {\r\n  if (!world) {\r\n    console.error('Failed to load the world');\r\n    return;\r\n  }\r\n\r\n  debugger;\r\n  console.log(world);\r\n});\r\n\r\n/*\r\n  How to access Zutand data outside of a component\r\n\r\n  useTileEntityManager.getState().entityList\r\n*/",{"ruleId":null,"fatal":true,"severity":2,"message":"19","line":17,"column":9},{"ruleId":"20","severity":2,"message":"21","line":3,"column":3,"nodeType":"22","messageId":"23","endLine":3,"endColumn":4,"fix":"24"},{"ruleId":"20","severity":2,"message":"21","line":13,"column":37,"nodeType":"22","messageId":"23","endLine":13,"endColumn":38,"fix":"25"},{"ruleId":"20","severity":2,"message":"21","line":14,"column":1,"nodeType":"22","messageId":"23","endLine":14,"endColumn":3,"fix":"26"},{"ruleId":"27","severity":1,"message":"28","line":26,"column":5,"nodeType":"29","messageId":"30","endLine":26,"endColumn":18},{"ruleId":"31","severity":2,"message":"32","line":30,"column":3,"nodeType":"33","messageId":"30","endLine":30,"endColumn":12},{"ruleId":"27","severity":1,"message":"28","line":31,"column":3,"nodeType":"29","messageId":"30","endLine":31,"endColumn":14},{"ruleId":"34","severity":2,"message":"35","line":38,"column":3,"nodeType":"22","messageId":"36","fix":"37"},"Parsing error: Unexpected token module","no-trailing-spaces","Trailing spaces not allowed.","Program","trailingSpace",{"range":"38","text":"39"},{"range":"40","text":"39"},{"range":"41","text":"39"},"no-console","Unexpected console statement.","MemberExpression","unexpected","no-debugger","Unexpected 'debugger' statement.","DebuggerStatement","eol-last","Newline required at end of file but not found.","missing",{"range":"42","text":"43"},[50,51],"",[533,534],[536,538],[1424,1424],"\n"]